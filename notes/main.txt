
This document explalins main.py in the order of which it has been written.


main() - The entry point/driver function that initializes and runs the Pygame application. It handles setup, the game loop, and cleanup.


## program initialization

base_path = os.path.dirname(os.path.abspath(__file__)) - This function chain retrieves the absolute directory path where the currently executing Python script resides. First, __file__ is a built-in variable that contains the path to the current file. os.path.abspath() converts this to an absolute path (resolving any relative components), and os.path.dirname() extracts just the directory portion, and excludes the file from the path. In main.py, this establishes the base directory for the application, ensuring consistent file access regardless of where the script was launched from. base_path "gets" gets the path info. 

os.chdir(base_path) sets the working directory to src/, which is crucial for ensuring consistent file access across the application. This approach has several important advantages:

1. Portability: It eliminates the need to hardcode absolute paths, making the code work across different systems and installations.
2. Reliability: Without this, relative file paths in the code would be relative to wherever the script was launched from (which could be unpredictable), potentially causing file not found errors.
3. Maintainability: If the project structure changes, base_path calculation is the only element that needs to be changed, not dozens of hardcoded paths throughout the codebase.

Alternative approaches include:
- Hardcoding absolute paths (brittle and non-portable)
- Using relative paths without changing directory (error-prone if script is run from different locations)
- Creating a config file with path settings (more complex for simple projects)
- Using path libraries like pathlib (modern alternative, but requires different syntax throughout)

pygame.init() - This function initializes all pygame modules at once. It's a convenience function that attempts to initialize the most common pygame modules (display, font, sound, input devices, etc.). While each pygame module can be initialized individually, pygame.init() provides a single call to set up everything needed for most games. It returns a tuple indicating success/failure counts for module initialization. This must be called before most other pygame functions can be used. If a module fails to initialize, the game may still run but with reduced functionality (e.g., no sound if the audio module fails).

pygame.font.init() - This function specifically initializes the pygame font module, which is responsible for creating and rendering text in pygame applications. While pygame.init() should initialize the font module automatically, explicitly calling pygame.font.init() ensures the font system is definitely ready for use, even if other parts of pygame.init() failed. This is a defensive programming practice that guarantees text rendering will work. After calling this function, you can create Font objects and render text to surfaces. Without proper font initialization, any attempt to create Font objects will raise pygame exceptions.


## SET DISPLAY AND CLOCK

screen = pygame.display.set_mode((1000, 1000)) - This function creates and returns a pygame Surface object representing the game window with the specified dimensions (width, height). Here, it creates a 1000x1000 pixel window. The returned surface is the primary drawing surface for the game. You can modify the window size by changing the values in the tuple. This function also initializes the display module if it hasn't been initialized yet. The screen variable stores this surface, which will be used throughout the game code for drawing graphics that should appear on screen.

clock = pygame.time.Clock() - This function creates a Clock object that can be used to track time and control the game's frame rate. The Clock object provides several essential timing functions:

1. Limiting frame rate: The tick() and tick_busy_loop() methods regulate how fast the game runs by introducing appropriate delays between frames to achieve a target frame rate (e.g., 60 FPS).
2. Measuring time: It can measure the time between frames (delta time) which is crucial for frame-rate independent movement and animations.
3. Performance monitoring: It can track and report the actual frame rate being achieved.

In the main game loop, clock.tick(60) limits the game to running at 60 frames per second by adding delays if the game is running too fast. This prevents the game from consuming 100% CPU and ensures consistent gameplay across different hardware. Without this frame rate control, the game would run at different speeds on different computers, making gameplay unpredictable. The Clock object is also used for debugging, as it can report the current frame rate which helps identify performance issues.

### INITIALIZE GAME MANAGERS 

projectile_mananger = ProjectileManager()

player = Player(projectile_manager)
blue_enemy = Blue(projectile_manager, position =(500, 200))

projectile_manager.add_target(blue_enemy)

all_sprites = pygame.sprite.Group()

all_sprites.add(player)
all_sprites.add(blue_enemy)

debug_system = DS()

### MAIN GAME LOOP 


running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

        if event.type ==pygame.KEYDOWN:
            if event.key ==pygame.K_ESCAPE:
            running = False
        if even.tkey == pygame.K_d:
            debug_system.toggle()
        if event.key == pygame.K_h:
        debug_system.toggle_hitboxes()

### UPDATE ALL GAME objects

all_sprites.update()
projectile_manager.update_projectiles()

### RENDER EVERYTHING 
screen.fill((0,0,0))
all_spries.draw(screen)
projectile_manager.draw_projectiles(screen)

## DRAW HITBOXES ENABLED BY PRESSING H
if debug_sytem.show_hitboxes: 
    blue_enemy.draw_hitbox(screen)

## RENDER DEBUG INFO AT THE end
debug_system.render_debug_info(screen, player, clock)

##
pygame.display.flip()

# Cap the frame rate

clock.tick(60)

logging.debug(f"Player position: {player.rect.center}")
logging.debug(f"blue position: {blue_enemy.rect.center}")

# CLEANING UP PROPERLY 

pygame.quit()
sys.texit()


if __name__ == "__main__":
    main()

__name__ - A special built-in variable in Python that contains the name of the current module. When a Python file is run directly, __name__ is set to "__main__". When imported as a module, __name__ is set to the module's name. This allows code to behave differently when run directly versus when imported. The pattern `if __name__ == "__main__": main()` is a common Python idiom that prevents the main code from executing when the file is imported as a module. This demonstrates the principle of modular design - using variables instead of literal values makes code more flexible and compatible with other systems. If you were to call main() directly without this check, the function would always run when the module is imported, which is usually not the desired behavior.
